üß± 1. Arquitetura e Estrutura
1.1 Clareza arquitetural

Descri√ß√£o: Definir claramente camadas, responsabilidades e fluxos de dados.

Por que: Facilita manuten√ß√£o, testes e evolu√ß√£o.

Boas pr√°ticas: Diagramas atualizados (C4 ou equivalente), separa√ß√£o por responsabilidade, depend√™ncias unidirecionais.

Erros comuns: Camadas se comunicando de forma circular ou sem fronteiras.

Verifique: Cada m√≥dulo sabe exatamente ‚Äúquem‚Äù pode cham√°-lo e ‚Äúpor qu√™‚Äù.

1.2 Coes√£o e baixo acoplamento

Descri√ß√£o: Cada m√≥dulo tem um prop√≥sito claro e m√≠nimo de depend√™ncias.

Por que: Reduz impacto de mudan√ßas e facilita testes.

Boas pr√°ticas: Uma classe/m√≥dulo deve fazer uma coisa bem definida (princ√≠pio da responsabilidade √∫nica).

Erros comuns: M√≥dulos que fazem ‚Äúde tudo‚Äù ou dependem de detalhes externos.

Verifique: Alterar uma funcionalidade deve afetar poucas partes do sistema.

1.3 Extensibilidade e substituibilidade

Descri√ß√£o: Permitir adicionar novos comportamentos sem alterar o n√∫cleo.

Por que: Evita regress√µes e permite evolu√ß√£o constante.

Boas pr√°ticas: Uso de interfaces, eventos, inje√ß√£o de depend√™ncias, configura√ß√µes externas.

Erros comuns: Switch-cases com regras fixas e c√≥digo duplicado.

Verifique: Adicionar uma nova regra ou caso n√£o deve quebrar o existente.

‚öôÔ∏è 2. C√≥digo e Design
2.1 Clareza e legibilidade

Descri√ß√£o: C√≥digo deve ser compreens√≠vel por outra pessoa em minutos.

Boas pr√°ticas: Nomes autoexplicativos, fun√ß√µes curtas, indenta√ß√£o consistente, coment√°rios explicando por que, n√£o como.

Erros comuns: Coment√°rios redundantes, vari√°veis gen√©ricas (x, temp), blocos longos.

Verifique: Outro desenvolvedor entende o prop√≥sito sem explica√ß√µes orais.

2.2 Simplicidade (KISS) e redu√ß√£o de complexidade

Descri√ß√£o: Resolver o problema da forma mais direta e clara poss√≠vel.

Boas pr√°ticas: Evite over-engineering, abstra√ß√µes desnecess√°rias e frameworks pesados.

Erros comuns: Criar camadas ou padr√µes onde n√£o h√° necessidade.

Verifique: Cada parte tem uma justificativa clara para existir.

2.3 Reuso controlado

Descri√ß√£o: Reutilizar o que √© realmente gen√©rico, evitando acoplamento excessivo.

Boas pr√°ticas: Crie bibliotecas/modos reutiliz√°veis apenas quando houver 2+ usos reais.

Erros comuns: ‚ÄúFrameworks internos‚Äù desnecess√°rios; depend√™ncias circulares.

Verifique: O reuso n√£o obriga depend√™ncias que n√£o deveriam existir.

2.4 Consist√™ncia de padr√µes

Descri√ß√£o: Todo o c√≥digo segue conven√ß√µes unificadas de formata√ß√£o, nomenclatura e estrutura.

Boas pr√°ticas: Linter, code style e revis√£o de PRs automatizados.

Erros comuns: Equipes usando estilos diferentes.

Verifique: Nenhum arquivo precisa ser ‚Äúdecifrado‚Äù para entender a estrutura.

üß© 3. L√≥gica, Algoritmos e Desempenho
3.1 Complexidade e efici√™ncia

Descri√ß√£o: Entender custo assint√≥tico (Big-O) das opera√ß√µes cr√≠ticas.

Boas pr√°ticas: Medir e otimizar apenas quando h√° gargalos reais.

Erros comuns: Otimizar prematuramente; ignorar complexidade em grandes volumes.

Verifique: Documentar a ordem de grandeza das partes sens√≠veis (O(n), O(log n)).

3.2 Responsividade e escalabilidade

Descri√ß√£o: O sistema deve manter desempenho mesmo sob carga crescente.

Boas pr√°ticas: Filas, cache, paralelismo, particionamento.

Erros comuns: Processar tudo sincronicamente ou em lote √∫nico.

Verifique: Testes de carga com comportamento previs√≠vel (sem degrada√ß√£o catastr√≥fica).

üîí 4. Seguran√ßa e Integridade
4.1 Valida√ß√£o de entrada

Descri√ß√£o: Toda entrada √© tratada como potencialmente maliciosa.

Boas pr√°ticas: Filtrar, normalizar e validar antes de usar.

Erros comuns: Confiar em dados vindos de cliente ou fontes externas.

Verifique: Testes com entradas inv√°lidas ou malformadas s√£o bloqueados corretamente.

4.2 Princ√≠pio do menor privil√©gio

Descri√ß√£o: Cada componente s√≥ deve ter acesso ao que realmente precisa.

Boas pr√°ticas: Escopos de permiss√µes, isolamento de contexto, vari√°veis m√≠nimas.

Erros comuns: Credenciais compartilhadas ou globais.

Verifique: Um m√≥dulo comprometido n√£o deve conseguir afetar outros.

4.3 Tratamento e exposi√ß√£o de erros

Descri√ß√£o: Mensagens de erro devem ser √∫teis para quem desenvolve, mas seguras para quem consome.

Boas pr√°ticas: Logs detalhados, mas respostas gen√©ricas.

Erros comuns: Expor stacktrace ou informa√ß√µes internas.

Verifique: Nenhum erro em produ√ß√£o revela caminhos ou nomes de classes.

üß™ 5. Testabilidade e Qualidade
5.1 Testabilidade desde o design

Descri√ß√£o: Estruturar o c√≥digo para poder ser testado isoladamente.

Boas pr√°ticas: Separar l√≥gica de neg√≥cio de I/O, permitir inje√ß√£o de depend√™ncias.

Erros comuns: Fun√ß√µes que criam seus pr√≥prios objetos ou acessos diretos a recursos.

Verifique: Cada unidade pode ser testada sem rodar o sistema completo.

5.2 Pir√¢mide de testes equilibrada

Descri√ß√£o: 70‚Äì80 % testes unit√°rios, 15‚Äì20 % integra√ß√£o, poucos E2E.

Boas pr√°ticas: Automatiza√ß√£o total, mocks apenas onde necess√°rio.

Erros comuns: S√≥ E2E ou s√≥ testes triviais.

Verifique: Cobertura est√°vel e testes r√°pidos em cada build.

5.3 Cobertura de c√≥digo significativa

Descri√ß√£o: M√©trica de apoio, n√£o um fim em si.

Boas pr√°ticas: Cobrir caminhos cr√≠ticos, exce√ß√µes e fluxos de erro.

Erros comuns: Cobertura alta, mas sem validar comportamento real.

Verifique: Relat√≥rios de cobertura analisados por risco, n√£o s√≥ porcentagem.

üìò 6. Documenta√ß√£o e Conhecimento
6.1 Documenta√ß√£o viva e √∫til

Descri√ß√£o: Documentar o essencial: como usar, como manter e como evoluir.

Boas pr√°ticas: README claro, exemplos, diagramas simples e atualizados.

Erros comuns: Textos longos, gen√©ricos ou desatualizados.

Verifique: Qualquer novo dev entende o sistema em minutos lendo o README.

6.2 Hist√≥rico e rastreabilidade

Descri√ß√£o: Saber por que uma decis√£o foi tomada.

Boas pr√°ticas: ADRs curtos (‚ÄúDecidimos usar X em vez de Y por Z‚Äù).

Erros comuns: Altera√ß√µes sem contexto.

Verifique: Toda mudan√ßa arquitetural tem justificativa registrada.

üöÄ 7. Evolu√ß√£o e Manuten√ß√£o
7.1 Refatora√ß√£o cont√≠nua

Descri√ß√£o: Melhorar pequenas partes em cada entrega.

Por que: Previne ‚Äúd√≠vida t√©cnica invis√≠vel‚Äù.

Boas pr√°ticas: Automatizar lint/complexidade e corrigir em tempo real.

Erros comuns: Acumular c√≥digo legado ‚Äútempor√°rio‚Äù.

Verifique: Complexidade m√©dia e m√©tricas de qualidade est√°veis.

7.2 Versionamento e controle de mudan√ßas

Descri√ß√£o: Uso disciplinado de versionamento sem√¢ntico e Git.

Boas pr√°ticas: Commits pequenos, mensagens descritivas, PRs curtos e revisados.

Erros comuns: Commits gen√©ricos (‚Äúfix bug‚Äù).

Verifique: Log do reposit√≥rio √© autoexplicativo.

üåê 8. Usabilidade e Experi√™ncia (mesmo em sistemas internos)
8.1 Feedback claro

Descri√ß√£o: Cada a√ß√£o deve ter retorno imediato e compreens√≠vel.

Por que: Evita erros de uso e melhora a confian√ßa do usu√°rio.

Boas pr√°ticas: Mensagens simples, estado de carregamento e erro bem definidos.

Erros comuns: Erros silenciosos ou gen√©ricos.

Verifique: Usu√°rio entende o que aconteceu sem suporte t√©cnico.

8.2 Consist√™ncia visual e comportamental

Descri√ß√£o: Elementos iguais se comportam igual em todo o sistema.

Boas pr√°ticas: Design System, conven√ß√µes de intera√ß√£o, padr√µes de layout.

Erros comuns: Bot√µes ou menus com comportamento imprevis√≠vel.

Verifique: Cada intera√ß√£o segue o mesmo padr√£o cognitivo.

üîÑ 9. Revis√£o e Colabora√ß√£o
9.1 Revis√£o de c√≥digo efetiva

Descri√ß√£o: An√°lise de qualidade, n√£o s√≥ busca de erros.

Boas pr√°ticas: Checklist de revis√£o (clareza, seguran√ßa, testes, legibilidade).

Erros comuns: PRs muito grandes; ‚ÄúLGTM‚Äù sem leitura real.

Verifique: Coment√°rios frequentes e aprendizado coletivo em revis√µes.

9.2 Padroniza√ß√£o entre equipes

Descri√ß√£o: Todos desenvolvedores seguem os mesmos guias e conven√ß√µes.

Boas pr√°ticas: Documentar padr√µes internos e revisar periodicamente.

Erros comuns: Diverg√™ncias por time ou projeto.

Verifique: C√≥digos de diferentes equipes t√™m apar√™ncia e estrutura compat√≠veis.

üìè 10. M√©tricas e Qualidade de C√≥digo
10.1 M√©tricas internas

Descri√ß√£o: Acompanhar complexidade, duplica√ß√£o, cobertura, bugs e vulnerabilidades.

Boas pr√°ticas: Ferramentas autom√°ticas (SonarQube, CodeClimate, etc.).

Erros comuns: Ignorar alertas cr√≠ticos.

Verifique: Nenhum critical blocker pendente antes do merge.

10.2 Revis√£o t√©cnica peri√≥dica

Descri√ß√£o: Revisar periodicamente se o sistema ainda segue boas pr√°ticas.

Boas pr√°ticas: Tech reviews trimestrais com checklist de arquitetura e c√≥digo.

Erros comuns: Manter decis√µes antigas mesmo obsoletas.

Verifique: Lista de d√©bitos t√©cnicos priorizada e controlada.

‚úÖ Resumo ‚Äî Checklist de Ouro do Desenvolvimento
√Årea	Boa pr√°tica essencial	Verifica√ß√£o r√°pida
Arquitetura	Camadas e fronteiras claras	Diagrama simples e atualizado
C√≥digo	Clareza, coes√£o e baixo acoplamento	Leitura de m√≥dulo sem confus√£o
Algoritmos	Complexidade e efici√™ncia conhecida	Nenhum gargalo √≥bvio
Seguran√ßa	Valida√ß√£o e isolamento	Testes de entrada inv√°lida
Testes	Pir√¢mide equilibrada	CI r√°pido e confi√°vel
Documenta√ß√£o	README e ADRs atualizados	Novo dev entende em 30 min
Manuten√ß√£o	Refatora√ß√£o constante	M√©tricas est√°veis
UX	Feedback claro e previs√≠vel	Nenhuma a√ß√£o sem resposta
Revis√£o	PR pequeno e revisado	Sem ‚Äúmerge direto‚Äù
M√©tricas	Monitorar qualidade do c√≥digo	Nenhum critical pendente